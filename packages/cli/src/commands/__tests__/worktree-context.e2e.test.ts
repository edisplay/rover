/**
 * ============================================================================
 * AUTOGENERATED E2E TEST FILE - DO NOT MODIFY MANUALLY
 * ============================================================================
 *
 * This file is automatically generated based on the E2E test specifications.
 * Any manual changes will be overwritten by the automation.
 *
 * To modify these tests, update the specification files:
 * - /docs/E2E_TESTS.md (root-level testing philosophy and constraints)
 * - /packages/cli/E2E_TESTS.md (CLI-specific test specifications)
 *
 * Then run the /update-e2e-tests command to regenerate this file.
 * ============================================================================
 */

import { beforeEach, afterEach, describe, it, expect } from 'vitest';
import {
  mkdtempSync,
  rmSync,
  writeFileSync,
  mkdirSync,
  chmodSync,
} from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { execa } from 'execa';

/**
 * E2E tests for worktree context detection
 *
 * These tests verify that when Rover commands are run from inside a git worktree,
 * Rover detects the context, shows a notification, and resolves operations against
 * the main repository root.
 */

describe('worktree context detection (e2e)', () => {
  let testDir: string;
  let originalCwd: string;
  let mockBinDir: string;
  let mockHomeDir: string;
  let originalPath: string;

  const createMockTool = (
    toolName: string,
    exitCode: number = 0,
    output: string = 'mock version 1.0.0'
  ) => {
    const scriptPath = join(mockBinDir, toolName);
    const scriptContent = `#!/usr/bin/env bash\necho "${output}"\nexit ${exitCode}`;
    writeFileSync(scriptPath, scriptContent);
    chmodSync(scriptPath, 0o755);
  };

  const createMockScript = (toolName: string, scriptContent: string) => {
    const scriptPath = join(mockBinDir, toolName);
    writeFileSync(scriptPath, scriptContent);
    chmodSync(scriptPath, 0o755);
  };

  const createMockClaude = () => {
    createMockScript(
      'claude',
      `#!/usr/bin/env bash
if [[ "$1" == "--version" ]]; then
  echo "Claude CLI v1.0.0"
  exit 0
fi

if [[ "$1" == "-p" ]]; then
  PROMPT=$(cat)
  if [[ "$2" == "--output-format" && "$3" == "json" ]]; then
    echo '{"result":"{\\"title\\":\\"Test task\\",\\"description\\":\\"A test task description.\\"}"}'
  else
    echo '{"title":"Test task","description":"A test task description."}'
  fi
  exit 0
fi

echo "Claude CLI v1.0.0"
exit 0
`
    );
  };

  const roverBin = join(__dirname, '../../../dist/index.mjs');

  const runRover = async (args: string[], cwd?: string) => {
    const testPath = `${mockBinDir}:${originalPath}`;
    return execa('node', [roverBin, ...args], {
      cwd: cwd || testDir,
      env: {
        PATH: testPath,
        HOME: mockHomeDir,
        USER: process.env.USER,
        TMPDIR: process.env.TMPDIR,
        ROVER_NO_TELEMETRY: '1',
      },
      reject: false,
    });
  };

  beforeEach(async () => {
    originalCwd = process.cwd();
    originalPath = process.env.PATH || '';

    testDir = mkdtempSync(join(tmpdir(), 'rover-worktree-ctx-e2e-'));
    process.chdir(testDir);

    mockBinDir = join(testDir, '.mock-bin');
    mkdirSync(mockBinDir, { recursive: true });

    // Create mock HOME directory with agent configuration files
    mockHomeDir = join(testDir, '.mock-home');
    mkdirSync(mockHomeDir, { recursive: true });
    writeFileSync(
      join(mockHomeDir, '.claude.json'),
      JSON.stringify({ version: 1 })
    );

    process.env.PATH = `${mockBinDir}:${originalPath}`;

    createMockTool('docker', 127, 'command not found: docker');
    createMockTool('claude', 127, 'command not found: claude');
    createMockTool('codex', 127, 'command not found: codex');
    createMockTool('cursor', 127, 'command not found: cursor');
    createMockTool('cursor-agent', 127, 'command not found: cursor-agent');
    createMockTool('gemini', 127, 'command not found: gemini');
    createMockTool('qwen', 127, 'command not found: qwen');
    createMockTool('opencode', 127, 'command not found: opencode');

    createMockTool('docker', 0, 'Docker version 24.0.0');
    createMockClaude();

    await execa('git', ['init']);
    await execa('git', ['config', 'user.email', 'test@test.com']);
    await execa('git', ['config', 'user.name', 'Test User']);
    await execa('git', ['config', 'commit.gpgsign', 'false']);

    writeFileSync(
      'package.json',
      JSON.stringify(
        { name: 'test-project', version: '1.0.0', type: 'module' },
        null,
        2
      )
    );
    writeFileSync('README.md', '# Test Project\n');

    await execa('git', ['add', '.']);
    await execa('git', ['commit', '-m', 'Initial commit']);

    await runRover(['init', '--yes']);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    process.env.PATH = originalPath;
    rmSync(testDir, { recursive: true, force: true });
  });

  describe('worktree detection and notification', () => {
    it('should show worktree notification when running from inside a git worktree', async () => {
      // Create a git worktree manually
      const worktreeDir = join(testDir, 'my-worktree');
      await execa(
        'git',
        ['worktree', 'add', worktreeDir, '-b', 'test-branch'],
        {
          cwd: testDir,
        }
      );

      // Run a rover command from inside the worktree (non-JSON mode)
      const result = await runRover(['list'], worktreeDir);

      // Verify: The worktree notification is displayed
      expect(result.stdout).toContain('git worktree');
      expect(result.stdout).toContain('main project root');
    });

    it('should not show worktree notification in JSON mode', async () => {
      // Create a git worktree manually
      const worktreeDir = join(testDir, 'my-worktree-json');
      await execa(
        'git',
        ['worktree', 'add', worktreeDir, '-b', 'test-branch-json'],
        {
          cwd: testDir,
        }
      );

      // Run a rover command from inside the worktree with --json flag
      const result = await runRover(['list', '--json'], worktreeDir);

      // Verify: No worktree notification in JSON mode
      expect(result.stdout).not.toContain('git worktree');
    });

    it('should not show worktree notification when running from the main checkout', async () => {
      // Run a rover command from the main checkout (not a worktree)
      const result = await runRover(['list']);

      // Verify: No worktree notification
      expect(result.stdout).not.toContain('git worktree');
    });

    it('should resolve operations against the main repository root from a worktree', async () => {
      // Create a task from the main checkout
      const taskResult = await runRover([
        'task',
        '-y',
        'Create a test file',
        '--json',
      ]);
      expect(taskResult.exitCode).toBe(0);

      // Create a separate worktree (not a task worktree)
      const worktreeDir = join(testDir, 'another-worktree');
      await execa(
        'git',
        ['worktree', 'add', worktreeDir, '-b', 'another-branch'],
        {
          cwd: testDir,
        }
      );

      // Run rover list from the worktree - should see the task created from main
      const listResult = await runRover(['list', '--json'], worktreeDir);

      expect(listResult.exitCode).toBe(0);
      const tasks = JSON.parse(listResult.stdout);
      expect(tasks.length).toBeGreaterThanOrEqual(1);
    });
  });
});

/**
 * ============================================================================
 * AUTOGENERATED E2E TEST FILE - DO NOT MODIFY MANUALLY
 * ============================================================================
 *
 * To modify these tests, update the specification files:
 * - /docs/E2E_TESTS.md (root-level testing philosophy and constraints)
 * - /packages/cli/E2E_TESTS.md (CLI-specific test specifications)
 *
 * Then run the /update-e2e-tests command to regenerate this file.
 * ============================================================================
 */
